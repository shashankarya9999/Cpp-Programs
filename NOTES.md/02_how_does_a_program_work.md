I'm going to feed an end of line character. Which is also available in the standard library. So why would an end of line character be in the standard library? Well, that allows me to be cross platform. So depending on which platform I'm on, if I compile this on Windows. You'll have a different end of line character to the file compiler on Unix, for example. And so, that byte, instead writing a platform specific end of line character. I chose the standard library, end of line character. It should work on all platforms. 

So actually, in order to convert that code into a runnable program. There's a few stages and we're going to look at some of those stages and see what the what comes out each stage. 

The first stage is one of the stage one of the early stages is to generate assembler. So essentially, it translates that c++ code into assembly language. And funnily enough, assembly language is a lower level language than c++. So the first step is to say. Okay, you've operated in c++ it's quite low level. But we're going to go even lower, closer to the hardware, and convert it to assembler. So let's just run that command, the g++ -S, and that will give us the assembler. So we jump back over here, g++ -S, and then I feed it the cpp. So that would generate a file, which is here. And we look at that file. You'll see that it contains a bunch of human readable, but still pretty confusing looking things. But actually what these are, all CPU operations. So these are all operations that the CPU itself understands. This is a low level language. So the CPU doesn't really understand Standard C out, but it does understand this stuff. So this is the first stage to convert the program into this. And yeah, as I say this is assembler, and some people actually code it. Sometimes people actually code in assembler in order to make really efficient or low level stuff. 

Okay, so the next step is to kind of convert this into maybe a lower level format that's even more interesting. So, so we do -C on that one. Then that will produce a file called main.o. And I'm going to read that. And, so this, again, this is starting to look like a bit like that kind of file that we saw earlier. But you might notice it's a bit smaller. So that's interesting. So we compare this main.o the object code to the actual layout file. You can see that the layout looks is has got more stuff in it basically. So, okay, so what's what's happening? We're actually now producing, if you like sort of machine readable executable code. So that's what the object code is. 

And then the final stage to get from that to the a out is to do something called linking. Which is basically I've used this this standard library iostream thing. So it needs to link to that that's already that's already been built as an object code or a library on my system. And so it's just connecting from my main to that, and then that's your a dot out. So and so the a.out is the thing we can actually run. So that's it. That's the final stage that we're going to look at there. 

*Summary*

Okay, so let's just review some of that. So we're just looking at what happens when we run that g++ command and compile and link our c++. So it's generating assembler, which is the low level thing and then it compiles the assembler down into object code. And then eventually, then links that object code to any other libraries that I've linked to. So in this case, it would have made a connection between my object code which is my code compiled into machine readable binary, and the library that lets me do printing out. Okay. So those languages, I like the associate C++ looks like that. We've seen C ++ already. So we wrote linger on that one, the assemble and that like that. So it's kind of lower level, but still a human readable, the object code. If I opened it in a hex editor would have looked like this. So you can see actually, it's not as bad as it might seem. You can kind of start reading some of the stuff in there on the right hand column. So that's your object code. And then finally, we can run it as, as we just saw. In this video, we've just gone through the process of compiling a c++ program and turning it into an executable block of binary. And we found that actually it goes through a few stages where it goes lower and lower level until you can actually run something on the hardware. 
